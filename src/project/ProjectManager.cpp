#include "project/ProjectManager.h"
#include <QFile>
#include <QFileInfo>
#include <QDir>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonArray>
#include <QLoggingCategory>
#include <QStandardPaths>

Q_LOGGING_CATEGORY(projectManager, "branchforge.project.manager")

namespace BranchForge::Project {

ProjectManager* ProjectManager::s_instance = nullptr;

ProjectManager& ProjectManager::instance() {
    if (!s_instance) {
        s_instance = new ProjectManager();
    }
    return *s_instance;
}

ProjectManager::ProjectManager(QObject* parent)
    : QObject(parent)
{
    qCInfo(projectManager) << "ProjectManager created";
}

ProjectManager::~ProjectManager() = default;

bool ProjectManager::createProject(const QString& path, const QString& name) {
    qCInfo(projectManager) << "Creating new project:" << name << "at" << path;
    
    QFileInfo fileInfo(path);
    
    // Create directory if it doesn't exist
    QDir dir = fileInfo.absoluteDir();
    if (!dir.exists()) {
        if (!dir.mkpath(".")) {
            qCWarning(projectManager) << "Failed to create project directory:" << dir.absolutePath();
            emit errorOccurred("Failed to create project directory");
            return false;
        }
    }
    
    m_projectPath = path;
    m_projectName = name;
    
    // Initialize default project structure
    m_projectSettings = QJsonObject{
        {"name", name},
        {"version", "1.0.0"},
        {"description", "BranchForge Behavior Tree Project"},
        {"ros2_package", name.toLower().replace(" ", "_")},
        {"target_language", "cpp20"}
    };
    
    // Create a default behavior tree
    m_behaviorTree = QJsonObject{
        {"root", QJsonObject{
            {"id", "root"},
            {"type", "sequence"},
            {"name", "Root Sequence"},
            {"x", 400},
            {"y", 50},
            {"children", QJsonArray()}
        }}
    };
    
    if (!saveProject()) {
        qCWarning(projectManager) << "Failed to save new project";
        return false;
    }
    
    emit projectChanged();
    qCInfo(projectManager) << "Project created successfully";
    return true;
}

bool ProjectManager::loadProject(const QString& path) {
    qCInfo(projectManager) << "Loading project from:" << path;
    
    if (!loadProjectFromFile(path)) {
        return false;
    }
    
    m_projectPath = path;
    emit projectChanged();
    qCInfo(projectManager) << "Project loaded successfully";
    return true;
}

bool ProjectManager::saveProject() {
    if (m_projectPath.isEmpty()) {
        qCWarning(projectManager) << "No project path set";
        emit errorOccurred("No project path set");
        return false;
    }
    
    if (saveProjectToFile(m_projectPath)) {
        emit projectSaved();
        qCInfo(projectManager) << "Project saved successfully";
        return true;
    }
    
    return false;
}

void ProjectManager::closeProject() {
    qCInfo(projectManager) << "Closing project";
    
    m_projectPath.clear();
    m_projectName.clear();
    m_behaviorTree = QJsonObject();
    m_projectSettings = QJsonObject();
    
    emit projectChanged();
}

QString ProjectManager::generateCppCode() const {
    if (!hasProject()) {
        return QString();
    }
    
    QString code;
    code += "// Generated by BranchForge\n";
    code += "// Project: " + m_projectName + "\n\n";
    code += "#include <behaviorTree.hpp>\n";
    code += "#include <rclcpp/rclcpp.hpp>\n\n";
    QString className = m_projectName;
    className.replace(" ", "");
    code += "class " + className + "BT {\n";
    code += "public:\n";
    code += "    " + className + "BT() {\n";
    code += "        // Initialize behavior tree\n";
    code += "        factory_.registerNodeType<MoveToAction>(\"MoveToAction\");\n";
    code += "        // Add more node registrations here\n";
    code += "    }\n\n";
    code += "    void run() {\n";
    code += "        // Load and execute behavior tree\n";
    code += "        auto tree = factory_.createTreeFromText(tree_xml_);\n";
    code += "        tree.tickRoot();\n";
    code += "    }\n\n";
    code += "private:\n";
    code += "    BT::BehaviorTreeFactory factory_;\n";
    code += "    std::string tree_xml_ = R\"(\n";
    code += "        <root main_tree_to_execute=\"MainTree\">\n";
    code += "            <BehaviorTree ID=\"MainTree\">\n";
    code += "                <Sequence>\n";
    code += "                    <!-- Add your behavior tree nodes here -->\n";
    code += "                </Sequence>\n";
    code += "            </BehaviorTree>\n";
    code += "        </root>\n";
    code += "    )\";\n";
    code += "};\n\n";
    code += "int main(int argc, char** argv) {\n";
    code += "    rclcpp::init(argc, argv);\n";
    code += "    " + className + "BT bt;\n";
    code += "    bt.run();\n";
    code += "    rclcpp::shutdown();\n";
    code += "    return 0;\n";
    code += "}\n";
    
    return code;
}

bool ProjectManager::saveProjectToFile(const QString& filePath) {
    QJsonObject projectJson = serializeProject();
    QJsonDocument doc(projectJson);
    
    QFile file(filePath);
    if (!file.open(QIODevice::WriteOnly)) {
        qCWarning(projectManager) << "Failed to open file for writing:" << filePath;
        emit errorOccurred("Failed to open file for writing");
        return false;
    }
    
    file.write(doc.toJson());
    return true;
}

bool ProjectManager::loadProjectFromFile(const QString& filePath) {
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly)) {
        qCWarning(projectManager) << "Failed to open file for reading:" << filePath;
        emit errorOccurred("Failed to open project file");
        return false;
    }
    
    QByteArray data = file.readAll();
    QJsonParseError error;
    QJsonDocument doc = QJsonDocument::fromJson(data, &error);
    
    if (error.error != QJsonParseError::NoError) {
        qCWarning(projectManager) << "JSON parse error:" << error.errorString();
        emit errorOccurred("Invalid project file format");
        return false;
    }
    
    return deserializeProject(doc.object());
}

QJsonObject ProjectManager::serializeProject() const {
    return QJsonObject{
        {"version", "1.0"},
        {"settings", m_projectSettings},
        {"behaviorTree", m_behaviorTree},
        {"metadata", QJsonObject{
            {"created", QDateTime::currentDateTime().toString(Qt::ISODate)},
            {"generator", "BranchForge 0.1.0"}
        }}
    };
}

bool ProjectManager::deserializeProject(const QJsonObject& json) {
    if (!json.contains("version") || !json.contains("settings") || !json.contains("behaviorTree")) {
        qCWarning(projectManager) << "Invalid project format - missing required fields";
        emit errorOccurred("Invalid project format");
        return false;
    }
    
    m_projectSettings = json["settings"].toObject();
    m_behaviorTree = json["behaviorTree"].toObject();
    m_projectName = m_projectSettings["name"].toString();
    
    return true;
}

} // namespace BranchForge::Project