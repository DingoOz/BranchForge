#include "project/BehaviorTreeXML.h"
#include <QFile>
#include <QTextStream>
#include <QUuid>
#include <QLoggingCategory>
#include <QRegularExpression>

Q_LOGGING_CATEGORY(btXML, "branchforge.project.xml")

namespace BranchForge::Project {

QString BTXMLNode::nodeTypeToString(NodeType type) {
    switch (type) {
        case Sequence: return "Sequence";
        case Selector: return "Selector";
        case Parallel: return "Parallel";
        case Inverter: return "Inverter";
        case Repeater: return "Repeater";
        case Retry: return "Retry";
        case Timeout: return "Timeout";
        case Action: return "Action";
        case Condition: return "Condition";
        case SubTree: return "SubTree";
        default: return "Unknown";
    }
}

BTXMLNode::NodeType BTXMLNode::stringToNodeType(const QString& typeStr) {
    if (typeStr == "Sequence") return Sequence;
    if (typeStr == "Selector") return Selector;
    if (typeStr == "Parallel") return Parallel;
    if (typeStr == "Inverter") return Inverter;
    if (typeStr == "Repeater") return Repeater;
    if (typeStr == "Retry") return Retry;
    if (typeStr == "Timeout") return Timeout;
    if (typeStr == "Action") return Action;
    if (typeStr == "Condition") return Condition;
    if (typeStr == "SubTree") return SubTree;
    return Action; // Default fallback
}

BehaviorTreeXML::BehaviorTreeXML()
    : m_treeName("Untitled Tree")
    , m_treeDescription("Generated by BranchForge")
{
    qCInfo(btXML) << "BehaviorTreeXML created";
}

BehaviorTreeXML::~BehaviorTreeXML() = default;

bool BehaviorTreeXML::importFromFile(const QString& filePath) {
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        qCWarning(btXML) << "Failed to open file for reading:" << filePath;
        return false;
    }
    
    QString content = file.readAll();
    return importFromString(content);
}

bool BehaviorTreeXML::importFromString(const QString& xmlContent) {
    qCInfo(btXML) << "Importing BT from XML string";
    
    QDomDocument doc;
    QString errorMsg;
    int errorLine, errorColumn;
    
    if (!doc.setContent(xmlContent, &errorMsg, &errorLine, &errorColumn)) {
        qCWarning(btXML) << "XML parsing error at line" << errorLine << "column" << errorColumn << ":" << errorMsg;
        return false;
    }
    
    clear();
    
    QDomElement root = doc.documentElement();
    if (root.tagName() != "BehaviorTree") {
        qCWarning(btXML) << "Invalid root element. Expected 'BehaviorTree', got:" << root.tagName();
        return false;
    }
    
    // Read tree metadata
    m_treeName = root.attribute("name", "Imported Tree");
    m_treeDescription = root.attribute("description", "Imported from XML");
    m_version = root.attribute("version", "1.0");
    m_rootNodeId = root.attribute("root_node_id");
    
    // Parse nodes
    QDomNodeList nodeList = root.elementsByTagName("Node");
    for (int i = 0; i < nodeList.count(); ++i) {
        QDomElement nodeElement = nodeList.at(i).toElement();
        parseXMLNode(nodeElement);
    }
    
    qCInfo(btXML) << "Successfully imported" << m_nodes.size() << "nodes";
    return validateTree();
}

bool BehaviorTreeXML::exportToFile(const QString& filePath) const {
    QString xmlContent = exportToString();
    if (xmlContent.isEmpty()) {
        return false;
    }
    
    QFile file(filePath);
    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        qCWarning(btXML) << "Failed to open file for writing:" << filePath;
        return false;
    }
    
    QTextStream out(&file);
    out << xmlContent;
    
    qCInfo(btXML) << "Exported BT to file:" << filePath;
    return true;
}

QString BehaviorTreeXML::exportToString() const {
    if (m_nodes.isEmpty()) {
        qCWarning(btXML) << "No nodes to export";
        return QString();
    }
    
    QString xmlString;
    QXmlStreamWriter writer(&xmlString);
    
    writer.setAutoFormatting(true);
    writer.setAutoFormattingIndent(2);
    
    writer.writeStartDocument();
    writer.writeComment("Generated by BranchForge - Behavior Tree XML");
    
    writer.writeStartElement("BehaviorTree");
    writer.writeAttribute("name", m_treeName);
    writer.writeAttribute("description", m_treeDescription);
    writer.writeAttribute("version", m_version);
    writer.writeAttribute("root_node_id", m_rootNodeId);
    writer.writeAttribute("generator", "BranchForge");
    
    // Write all nodes
    for (const auto& node : m_nodes) {
        writeXMLNode(writer, node);
    }
    
    writer.writeEndElement(); // BehaviorTree
    writer.writeEndDocument();
    
    qCInfo(btXML) << "Exported" << m_nodes.size() << "nodes to XML string";
    return xmlString;
}

void BehaviorTreeXML::addNode(const BTXMLNode& node) {
    // Generate ID if not provided
    BTXMLNode newNode = node;
    if (newNode.id.isEmpty()) {
        newNode.id = generateNodeId();
    }
    
    // Check for duplicate IDs
    for (const auto& existingNode : m_nodes) {
        if (existingNode.id == newNode.id) {
            qCWarning(btXML) << "Node with ID already exists:" << newNode.id;
            return;
        }
    }
    
    m_nodes.append(newNode);
    qCDebug(btXML) << "Added node:" << newNode.id << newNode.type << newNode.name;
}

void BehaviorTreeXML::removeNode(const QString& nodeId) {
    for (int i = 0; i < m_nodes.size(); ++i) {
        if (m_nodes[i].id == nodeId) {
            // Remove this node from any parent's children list
            for (auto& node : m_nodes) {
                node.children.removeAll(nodeId);
            }
            
            m_nodes.removeAt(i);
            qCDebug(btXML) << "Removed node:" << nodeId;
            return;
        }
    }
    qCWarning(btXML) << "Node not found for removal:" << nodeId;
}

void BehaviorTreeXML::updateNode(const QString& nodeId, const BTXMLNode& updatedNode) {
    for (auto& node : m_nodes) {
        if (node.id == nodeId) {
            BTXMLNode newNode = updatedNode;
            newNode.id = nodeId; // Preserve ID
            node = newNode;
            qCDebug(btXML) << "Updated node:" << nodeId;
            return;
        }
    }
    qCWarning(btXML) << "Node not found for update:" << nodeId;
}

BTXMLNode* BehaviorTreeXML::findNode(const QString& nodeId) {
    for (auto& node : m_nodes) {
        if (node.id == nodeId) {
            return &node;
        }
    }
    return nullptr;
}

bool BehaviorTreeXML::validateTree() const {
    m_validationErrors.clear();
    
    if (m_nodes.isEmpty()) {
        m_validationErrors << "Tree contains no nodes";
        return false;
    }
    
    // Check for root node
    if (m_rootNodeId.isEmpty()) {
        m_validationErrors << "No root node specified";
        return false;
    }
    
    BTXMLNode* rootNode = const_cast<BehaviorTreeXML*>(this)->findNode(m_rootNodeId);
    if (!rootNode) {
        m_validationErrors << "Root node not found: " + m_rootNodeId;
        return false;
    }
    
    // Check for orphaned nodes (nodes with invalid parent references)
    for (const auto& node : m_nodes) {
        if (!node.parentId.isEmpty()) {
            BTXMLNode* parent = const_cast<BehaviorTreeXML*>(this)->findNode(node.parentId);
            if (!parent) {
                m_validationErrors << QString("Node %1 has invalid parent: %2").arg(node.id, node.parentId);
            }
        }
    }
    
    // Check for circular references
    QSet<QString> visited;
    QSet<QString> recursionStack;
    
    std::function<bool(const QString&)> hasCycle = [&](const QString& nodeId) -> bool {
        if (recursionStack.contains(nodeId)) {
            m_validationErrors << "Circular reference detected involving node: " + nodeId;
            return true;
        }
        
        if (visited.contains(nodeId)) {
            return false;
        }
        
        visited.insert(nodeId);
        recursionStack.insert(nodeId);
        
        BTXMLNode* node = const_cast<BehaviorTreeXML*>(this)->findNode(nodeId);
        if (node) {
            for (const QString& childId : node->children) {
                if (hasCycle(childId)) {
                    return true;
                }
            }
        }
        
        recursionStack.remove(nodeId);
        return false;
    };
    
    if (hasCycle(m_rootNodeId)) {
        return false;
    }
    
    qCInfo(btXML) << "Tree validation completed successfully";
    return m_validationErrors.isEmpty();
}

QStringList BehaviorTreeXML::getValidationErrors() const {
    return m_validationErrors;
}

QString BehaviorTreeXML::exportToBehaviorTreeCPP() const {
    QString xmlString;
    QXmlStreamWriter writer(&xmlString);
    
    writer.setAutoFormatting(true);
    writer.setAutoFormattingIndent(2);
    
    writer.writeStartDocument();
    writer.writeComment("BehaviorTree.CPP format - Generated by BranchForge");
    
    writer.writeStartElement("root");
    writer.writeAttribute("main_tree_to_execute", m_treeName);
    
    writer.writeStartElement("BehaviorTree");
    writer.writeAttribute("ID", m_treeName);
    
    // Write tree structure starting from root
    if (!m_rootNodeId.isEmpty()) {
        BTXMLNode* rootNode = const_cast<BehaviorTreeXML*>(this)->findNode(m_rootNodeId);
        if (rootNode) {
            std::function<void(const BTXMLNode*)> writeNodeRecursive = [&](const BTXMLNode* node) {
                writer.writeStartElement(node->type);
                
                if (!node->name.isEmpty() && node->name != node->type) {
                    writer.writeAttribute("name", node->name);
                }
                
                // Write parameters
                for (auto it = node->parameters.begin(); it != node->parameters.end(); ++it) {
                    writer.writeAttribute(it.key(), it.value());
                }
                
                // Write children
                for (const QString& childId : node->children) {
                    BTXMLNode* childNode = const_cast<BehaviorTreeXML*>(this)->findNode(childId);
                    if (childNode) {
                        writeNodeRecursive(childNode);
                    }
                }
                
                writer.writeEndElement();
            };
            
            writeNodeRecursive(rootNode);
        }
    }
    
    writer.writeEndElement(); // BehaviorTree
    writer.writeEndElement(); // root
    writer.writeEndDocument();
    
    return xmlString;
}

QString BehaviorTreeXML::exportToGroot2() const {
    // Groot2 uses a different XML format with positioning information
    QString xmlString;
    QXmlStreamWriter writer(&xmlString);
    
    writer.setAutoFormatting(true);
    writer.setAutoFormattingIndent(2);
    
    writer.writeStartDocument();
    writer.writeComment("Groot2 format - Generated by BranchForge");
    
    writer.writeStartElement("BehaviorTree");
    writer.writeAttribute("ID", m_treeName);
    
    // Groot2 includes positioning information
    for (const auto& node : m_nodes) {
        writer.writeStartElement("TreeNode");
        writer.writeAttribute("ID", node.id);
        writer.writeAttribute("name", node.name);
        writer.writeAttribute("type", node.type);
        writer.writeAttribute("x", QString::number(node.position.x()));
        writer.writeAttribute("y", QString::number(node.position.y()));
        
        if (!node.parentId.isEmpty()) {
            writer.writeAttribute("parent", node.parentId);
        }
        
        // Write parameters
        for (auto it = node.parameters.begin(); it != node.parameters.end(); ++it) {
            writer.writeAttribute(it.key(), it.value());
        }
        
        writer.writeEndElement();
    }
    
    writer.writeEndElement(); // BehaviorTree
    writer.writeEndDocument();
    
    return xmlString;
}

void BehaviorTreeXML::clear() {
    m_nodes.clear();
    m_rootNodeId.clear();
    m_treeName = "Untitled Tree";
    m_treeDescription = "Generated by BranchForge";
    m_validationErrors.clear();
    qCDebug(btXML) << "Cleared all tree data";
}

void BehaviorTreeXML::parseXMLNode(const QDomElement& element, const QString& parentId) {
    BTXMLNode node;
    node.id = element.attribute("id", generateNodeId());
    node.type = element.attribute("type", "Action");
    node.name = element.attribute("name", node.type);
    node.description = element.attribute("description");
    node.position.setX(element.attribute("x", "0").toDouble());
    node.position.setY(element.attribute("y", "0").toDouble());
    node.parentId = parentId;
    
    // Parse parameters
    QDomNamedNodeMap attributes = element.attributes();
    for (int i = 0; i < attributes.count(); ++i) {
        QDomNode attr = attributes.item(i);
        QString name = attr.nodeName();
        QString value = attr.nodeValue();
        
        // Skip standard attributes
        if (name != "id" && name != "type" && name != "name" && 
            name != "description" && name != "x" && name != "y") {
            node.parameters[name] = value;
        }
    }
    
    // Parse child connections
    QDomNodeList children = element.elementsByTagName("Connection");
    for (int i = 0; i < children.count(); ++i) {
        QDomElement childElement = children.at(i).toElement();
        QString childId = childElement.attribute("target");
        if (!childId.isEmpty()) {
            node.children.append(childId);
        }
    }
    
    addNode(node);
}

void BehaviorTreeXML::writeXMLNode(QXmlStreamWriter& writer, const BTXMLNode& node) const {
    writer.writeStartElement("Node");
    writer.writeAttribute("id", node.id);
    writer.writeAttribute("type", node.type);
    writer.writeAttribute("name", node.name);
    
    if (!node.description.isEmpty()) {
        writer.writeAttribute("description", node.description);
    }
    
    writer.writeAttribute("x", QString::number(node.position.x()));
    writer.writeAttribute("y", QString::number(node.position.y()));
    
    if (!node.parentId.isEmpty()) {
        writer.writeAttribute("parent_id", node.parentId);
    }
    
    // Write parameters
    for (auto it = node.parameters.begin(); it != node.parameters.end(); ++it) {
        writer.writeAttribute(it.key(), it.value());
    }
    
    // Write child connections
    for (const QString& childId : node.children) {
        writer.writeStartElement("Connection");
        writer.writeAttribute("target", childId);
        writer.writeEndElement();
    }
    
    writer.writeEndElement(); // Node
}

QString BehaviorTreeXML::generateNodeId() const {
    return "node_" + QUuid::createUuid().toString(QUuid::WithoutBraces).left(8);
}

bool BehaviorTreeXML::isValidConnection(const QString& parentId, const QString& childId) const {
    // Basic validation - could be expanded with type-specific rules
    return parentId != childId && findNode(parentId) && findNode(childId);
}

// BTXMLTransformer implementation
QString BTXMLTransformer::convertFromGroot(const QString& grootXML) {
    // Convert Groot format to BranchForge format
    QDomDocument doc = parseToDom(grootXML);
    if (doc.isNull()) {
        return QString();
    }
    
    // Implementation would parse Groot-specific format and convert
    // This is a simplified placeholder
    return grootXML;
}

QString BTXMLTransformer::convertFromBehaviorTreeCPP(const QString& btcppXML) {
    // Convert BehaviorTree.CPP format to BranchForge format
    QDomDocument doc = parseToDom(btcppXML);
    if (doc.isNull()) {
        return QString();
    }
    
    // Implementation would parse BT.CPP-specific format and convert
    // This is a simplified placeholder
    return btcppXML;
}

QString BTXMLTransformer::convertToGroot(const QString& branchForgeXML) {
    BehaviorTreeXML bt;
    if (bt.importFromString(branchForgeXML)) {
        return bt.exportToGroot2();
    }
    return QString();
}

QString BTXMLTransformer::convertToBehaviorTreeCPP(const QString& branchForgeXML) {
    BehaviorTreeXML bt;
    if (bt.importFromString(branchForgeXML)) {
        return bt.exportToBehaviorTreeCPP();
    }
    return QString();
}

bool BTXMLTransformer::validateBehaviorTreeCPPXML(const QString& xmlContent) {
    QDomDocument doc = parseToDom(xmlContent);
    if (doc.isNull()) {
        return false;
    }
    
    QDomElement root = doc.documentElement();
    return root.tagName() == "root" && !root.elementsByTagName("BehaviorTree").isEmpty();
}

bool BTXMLTransformer::validateGrootXML(const QString& xmlContent) {
    QDomDocument doc = parseToDom(xmlContent);
    if (doc.isNull()) {
        return false;
    }
    
    QDomElement root = doc.documentElement();
    return root.tagName() == "BehaviorTree" && !root.elementsByTagName("TreeNode").isEmpty();
}

QDomDocument BTXMLTransformer::parseToDom(const QString& xmlContent) {
    QDomDocument doc;
    if (!doc.setContent(xmlContent)) {
        return QDomDocument();
    }
    return doc;
}

QString BTXMLTransformer::domToString(const QDomDocument& doc) {
    return doc.toString(2);
}

} // namespace BranchForge::Project