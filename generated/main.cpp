// Generated by BranchForge on 2025-06-13T08:48:17
// Project: MyBehaviorTree
// Description: Generated by BranchForge - MyBehaviorTree

#include <behaviortree_cpp/bt_factory.h>
#include <behaviortree_cpp/loggers/bt_cout_logger.h>
#include <rclcpp/rclcpp.hpp>
#include <ament_index_cpp/get_package_share_directory.hpp>
#include <concepts>
#include <memory>
#include <string>
#include <iostream>


// Modern C++20 Concepts for Behavior Tree Nodes
#include <concepts>

template<typename T>
concept BehaviorTreeNode = requires(T t) {
    { t.tick() } -> std::same_as<BT::NodeStatus>;
    { t.providedPorts() } -> std::same_as<BT::PortsList>;
};

template<typename T>
concept ActionNode = BehaviorTreeNode<T> && std::derived_from<T, BT::ActionNodeBase>;

template<typename T>
concept ConditionNode = BehaviorTreeNode<T> && std::derived_from<T, BT::ConditionNode>;

template<typename T>
concept ControlNode = BehaviorTreeNode<T> && std::derived_from<T, BT::ControlNode>;

template<typename T>
concept DecoratorNode = BehaviorTreeNode<T> && std::derived_from<T, BT::DecoratorNode>;



namespace MyProject {

int main(int argc, char** argv) {
    // Initialize ROS2
    rclcpp::init(argc, argv);
    auto node = rclcpp::Node::make_shared("MyBehaviorTree_node");
    
    // Create BehaviorTree factory
    BT::BehaviorTreeFactory factory;
    
    // Register custom nodes
    factory.registerNodeType<Sequence>("Sequence");
    factory.registerNodeType<Forcesuccess>("Force Success");
    
    // Create tree from XML
    std::string xml_text = R"XML(
<?xml version="1.0"?>
<!--BehaviorTree.CPP format - Generated by BranchForge-->
<root main_tree_to_execute="MyBehaviorTree">
  <BehaviorTree ID="MyBehaviorTree">
    <sequence name="Sequence">
      <force_success name="Force Success"/>
    </sequence>
  </BehaviorTree>
</root>

)XML";
    
    auto tree = factory.createTreeFromText(xml_text);
    
    // Add logger
    BT::StdCoutLogger logger(tree);
    
    // Main execution loop
    BT::NodeStatus status = BT::NodeStatus::RUNNING;
    while (rclcpp::ok() && status == BT::NodeStatus::RUNNING) {
        status = tree.tickRoot();
        rclcpp::spin_some(node);
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
    
    // Cleanup
    rclcpp::shutdown();
    return status == BT::NodeStatus::SUCCESS ? 0 : 1;
}

} // namespace MyProject
